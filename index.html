<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>For Yusra, with love</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Georgia', 'Times New Roman', serif;
        }
        /* Intro overlay with clickable heart */
        #intro-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #fce4ec; /* soft pink */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            cursor: pointer;
            transition: opacity 1.5s ease;
            pointer-events: auto;
            backdrop-filter: blur(5px);
        }
        #intro-heart {
            font-size: 25vw;
            line-height: 1;
            animation: heartbeat 1.8s infinite;
            filter: drop-shadow(0 0 30px #ff8da1);
            user-select: none;
        }
        #intro-text {
            font-size: 1.8rem;
            color: #b3546b;
            margin-top: 20px;
            letter-spacing: 2px;
            text-shadow: 0 0 15px white;
            font-weight: 300;
        }
        @keyframes heartbeat {
            0% { transform: scale(1); }
            25% { transform: scale(1.1); }
            35% { transform: scale(1); }
            45% { transform: scale(1.05); }
            55% { transform: scale(1); }
            100% { transform: scale(1); }
        }
        /* Main message and letter (visible after overlay fades) */
        #main-message {
            position: absolute;
            top: 30px;
            left: 0;
            width: 100%;
            text-align: center;
            color: #fff0f5;
            text-shadow: 0 0 15px #ffb6c1, 0 0 30px #ffb6c1;
            z-index: 10;
            font-size: 2.5rem;
            font-weight: 400;
            letter-spacing: 2px;
            animation: softGlow 4s infinite alternate;
            pointer-events: none;
        }
        @keyframes softGlow {
            0% { text-shadow: 0 0 15px #ffb6c1, 0 0 30px #ffb6c1; }
            100% { text-shadow: 0 0 25px #ffc0cb, 0 0 50px #ff99aa; }
        }
        #letter {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 85%;
            max-width: 650px;
            background: rgba(255, 240, 245, 0.2);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-left: 5px solid #ffb6c1;
            border-radius: 24px;
            padding: 25px 30px;
            color: #2e1b2e;
            font-size: 1.1rem;
            line-height: 1.7;
            box-shadow: 0 20px 40px rgba(0,0,0,0.2), 0 0 0 1px rgba(255,255,255,0.2) inset;
            z-index: 20;
            max-height: 50vh;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #ffb6c1 rgba(255,255,255,0.2);
            pointer-events: none;
            text-shadow: 0 1px 3px rgba(255,255,255,0.3);
        }
        #letter::-webkit-scrollbar {
            width: 6px;
        }
        #letter::-webkit-scrollbar-track {
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
        }
        #letter::-webkit-scrollbar-thumb {
            background: #ffb6c1;
            border-radius: 10px;
        }
        #letter p {
            margin: 0 0 16px 0;
        }
        #letter .signature {
            text-align: right;
            font-size: 1.3rem;
            color: #b3546b;
            margin-top: 20px;
            border-top: 1px dashed rgba(255,182,193,0.5);
            padding-top: 15px;
            font-style: italic;
        }
        .instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255,255,255,0.7);
            font-size: 0.9rem;
            z-index: 15;
            pointer-events: none;
            background: rgba(255,240,245,0.2);
            padding: 6px 12px;
            border-radius: 30px;
            backdrop-filter: blur(4px);
            border: 1px solid rgba(255,255,255,0.2);
        }
        @media (max-width: 700px) {
            #main-message { font-size: 2rem; top: 15px; }
            #letter { font-size: 1rem; padding: 20px; width: 90%; bottom: 20px; }
            #intro-text { font-size: 1.2rem; }
        }
    </style>
</head>
<body>
    <!-- Intro clickable heart overlay -->
    <div id="intro-overlay" onclick="startCard()">
        <div id="intro-heart">‚ù§Ô∏è</div>
        <div id="intro-text">Tap to open for Yusra</div>
    </div>

    <!-- Main content (visible after overlay fades) -->
    <div id="main-message">üíó Happy Valentine's Day, Yusra Baby üíó</div>
    
    <div id="letter">
        <p>My dearest valentine,<br>Yusra Baby ‚ù§Ô∏è‚ù§Ô∏è</p>
        <p>Every day that passes, my love for you grows stronger. You bring so much light and happiness into my life. Your kindness, your sense of humor, and your unwavering support all make me feel so incredibly lucky to have you by my side.</p>
        <p>You are the sun that brightens my sky, the beat that keeps my heart rhythm, and the missing puzzle piece that completes me. You are my rock, my best friend, and my soulmate all rolled into one. The thought of spending the rest of my life with you by my side fills me with so much joy and contentment.</p>
        <p>I am so grateful for the time we have spent together and the memories we have made. I am excited for what the future holds and for all the adventures we will embark on together.</p>
        <p>My love for you is immeasurable and I will love you forever and always.</p>
        <div class="signature">Happy Valentine's Day, my love.<br>Love, Abhinav</div>
    </div>

    <div class="instructions">‚ú® Drag to rotate ‚Ä¢ Scroll to zoom ‚Ä¢ Auto‚Äërotate on ‚ú®</div>

    <!-- Three.js imports -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        // --- Hide intro overlay function (called from global) ---
        window.startCard = function() {
            const overlay = document.getElementById('intro-overlay');
            overlay.style.opacity = '0';
            setTimeout(() => {
                overlay.style.pointerEvents = 'none';
                overlay.style.display = 'none'; // optional
            }, 1500);
        };

        // --- Soft, romantic scene (initialized immediately) ---
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf9e6f0); // soft pinkish cream

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 2.5, 8);
        camera.lookAt(0, 0.5, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.1;
        document.body.appendChild(renderer.domElement);

        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.left = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(labelRenderer.domElement);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 1.5;
        controls.enableZoom = true;
        controls.maxPolarAngle = Math.PI / 2;
        controls.target.set(0, 0.8, 0);

        // --- Soft lighting ---
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);

        const keyLight = new THREE.DirectionalLight(0xffeef5, 1.0);
        keyLight.position.set(3, 5, 4);
        keyLight.castShadow = true;
        keyLight.receiveShadow = true;
        keyLight.shadow.mapSize.width = 1024;
        keyLight.shadow.mapSize.height = 1024;
        const d = 8;
        keyLight.shadow.camera.left = -d;
        keyLight.shadow.camera.right = d;
        keyLight.shadow.camera.top = d;
        keyLight.shadow.camera.bottom = -d;
        keyLight.shadow.camera.near = 2;
        keyLight.shadow.camera.far = 20;
        scene.add(keyLight);

        const fillLight = new THREE.PointLight(0xffd9e6, 0.7);
        fillLight.position.set(-3, 2, 3);
        scene.add(fillLight);

        const backLight = new THREE.PointLight(0xffccdd, 0.5);
        backLight.position.set(0, 2, -5);
        scene.add(backLight);

        const heartGlow = new THREE.PointLight(0xffb6c1, 1.2, 10);
        heartGlow.position.set(0, 0.8, 1.5);
        scene.add(heartGlow);

        // --- Pastel heart ---
        const heartGroup = new THREE.Group();

        // Soft pink material
        const material = new THREE.MeshStandardMaterial({
            color: 0xffb6c1,
            emissive: 0x55333b,
            roughness: 0.25,
            metalness: 0.1,
            emissiveIntensity: 0.4
        });

        // Left lobe
        const sphere1 = new THREE.Mesh(new THREE.SphereGeometry(1.05, 48, 48), material);
        sphere1.position.set(-1.15, 0.6, 0);
        sphere1.scale.set(1, 0.9, 0.8);
        sphere1.castShadow = true;
        sphere1.receiveShadow = true;
        heartGroup.add(sphere1);

        // Right lobe
        const sphere2 = new THREE.Mesh(new THREE.SphereGeometry(1.05, 48, 48), material);
        sphere2.position.set(1.15, 0.6, 0);
        sphere2.scale.set(1, 0.9, 0.8);
        sphere2.castShadow = true;
        sphere2.receiveShadow = true;
        heartGroup.add(sphere2);

        // Bottom tip
        const tipGeo = new THREE.ConeGeometry(0.95, 1.7, 64);
        const tipMat = new THREE.MeshStandardMaterial({ color: 0xffb6c1, emissive: 0x442a33, roughness: 0.25 });
        const tip = new THREE.Mesh(tipGeo, tipMat);
        tip.position.set(0, -0.7, 0);
        tip.scale.set(0.9, 0.8, 0.7);
        tip.castShadow = true;
        tip.receiveShadow = true;
        heartGroup.add(tip);

        // Bottom sphere
        const bottomSphere = new THREE.Mesh(new THREE.SphereGeometry(0.6, 24), material);
        bottomSphere.position.set(0, -1.3, 0.1);
        bottomSphere.scale.set(0.7, 0.4, 0.5);
        bottomSphere.castShadow = true;
        bottomSphere.receiveShadow = true;
        heartGroup.add(bottomSphere);

        // Inner glow (semi-transparent)
        const innerMat = new THREE.MeshStandardMaterial({
            color: 0xffd9e6,
            emissive: 0xffb6c1,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.5
        });
        const innerSphere1 = new THREE.Mesh(new THREE.SphereGeometry(0.7, 32), innerMat);
        innerSphere1.position.set(-0.8, 0.5, 0.3);
        innerSphere1.scale.set(0.8, 0.7, 0.6);
        heartGroup.add(innerSphere1);
        
        const innerSphere2 = new THREE.Mesh(new THREE.SphereGeometry(0.7, 32), innerMat);
        innerSphere2.position.set(0.8, 0.5, 0.3);
        innerSphere2.scale.set(0.8, 0.7, 0.6);
        heartGroup.add(innerSphere2);

        scene.add(heartGroup);

        // --- Animated couple hearts (two special hearts that float together) ---
        function createHeartSprite(color) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 64, 64);
            ctx.fillStyle = color;
            ctx.shadowColor = 'rgba(255,200,220,0.8)';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.moveTo(32, 52);
            ctx.bezierCurveTo(12, 36, 0, 24, 16, 8);
            ctx.bezierCurveTo(24, 0, 32, 4, 32, 12);
            ctx.bezierCurveTo(32, 4, 40, 0, 48, 8);
            ctx.bezierCurveTo(64, 24, 52, 36, 32, 52);
            ctx.fill();
            return new THREE.CanvasTexture(canvas);
        }

        const spriteMat1 = new THREE.SpriteMaterial({ map: createHeartSprite('#ffb6c1'), blending: THREE.NormalBlending, depthTest: true });
        const spriteMat2 = new THREE.SpriteMaterial({ map: createHeartSprite('#ffc0cb'), blending: THREE.NormalBlending, depthTest: true });

        const coupleHeart1 = new THREE.Sprite(spriteMat1);
        const coupleHeart2 = new THREE.Sprite(spriteMat2);
        coupleHeart1.scale.set(0.9, 0.9, 1);
        coupleHeart2.scale.set(0.9, 0.9, 1);
        scene.add(coupleHeart1);
        scene.add(coupleHeart2);

        // Additional floating hearts ring
        const ringCount = 10;
        const ringSprites = [];
        for (let i = 0; i < ringCount; i++) {
            const mat = new THREE.SpriteMaterial({ map: createHeartSprite('#ffd9e6'), blending: THREE.NormalBlending });
            const sprite = new THREE.Sprite(mat);
            const angle = (i / ringCount) * Math.PI * 2;
            sprite.position.set(
                Math.cos(angle) * 3.5,
                0.5 + Math.sin(angle * 2) * 0.3,
                Math.sin(angle) * 3.5
            );
            sprite.scale.set(0.6, 0.6, 1);
            scene.add(sprite);
            ringSprites.push({ sprite, angle, speed: 0.3 + Math.random()*0.2, offset: Math.random()*10 });
        }

        // --- Soft particles (sparkles) ---
        const particleCount = 400;
        const particlesGeo = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const color = new THREE.Color();

        for (let i = 0; i < particleCount; i++) {
            const r = 2.5 + Math.random() * 6;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            positions[i*3] = r * Math.sin(phi) * Math.cos(theta);
            positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i*3+2] = r * Math.cos(phi);

            const hue = 0.95 + Math.random() * 0.1; // pink range
            color.setHSL(hue, 0.6, 0.7); // softer
            colors[i*3] = color.r;
            colors[i*3+1] = color.g;
            colors[i*3+2] = color.b;
        }
        particlesGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particlesGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const particleMat = new THREE.PointsMaterial({
            size: 0.12,
            vertexColors: true,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            sizeAttenuation: true
        });
        const particles = new THREE.Points(particlesGeo, particleMat);
        scene.add(particles);

        // --- Background stars (soft white) ---
        const starsGeo = new THREE.BufferGeometry();
        const starsPos = new Float32Array(600 * 3);
        for (let i = 0; i < 600; i++) {
            starsPos[i*3] = (Math.random() - 0.5) * 80;
            starsPos[i*3+1] = (Math.random() - 0.5) * 50;
            starsPos[i*3+2] = (Math.random() - 0.5) * 80 - 30;
        }
        starsGeo.setAttribute('position', new THREE.BufferAttribute(starsPos, 3));
        const starsMat = new THREE.PointsMaterial({ color: 0xfff0f5, size: 0.1, transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending });
        const stars = new THREE.Points(starsGeo, starsMat);
        scene.add(stars);

        // --- Very subtle ground reflection ---
        const groundGeo = new THREE.CircleGeometry(12, 32);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0xffeef5, emissive: 0xffd9e6, transparent: true, opacity: 0.1, side: THREE.DoubleSide });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -1.8;
        ground.receiveShadow = true;
        scene.add(ground);

        // --- Animation loop ---
        let clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const elapsedTime = performance.now() / 1000;

            // Heartbeat
            const beat = Math.sin(elapsedTime * 6) * 0.015;
            heartGroup.scale.setScalar(1 + beat);

            // Rotate particles gently
            particles.rotation.y += 0.0002;
            stars.rotation.y += 0.0001;

            // Animate couple hearts (they orbit together)
            const angle = elapsedTime * 0.5;
            const radius = 2.8;
            const yOffset = Math.sin(elapsedTime * 1.5) * 0.5;
            coupleHeart1.position.set(
                Math.cos(angle) * radius,
                0.8 + Math.sin(angle * 2) * 0.3 + yOffset,
                Math.sin(angle) * radius
            );
            coupleHeart2.position.set(
                Math.cos(angle + 0.8) * radius,
                0.8 + Math.sin(angle * 2 + 1) * 0.3 + yOffset,
                Math.sin(angle + 0.8) * radius
            );

            // Animate ring sprites
            ringSprites.forEach((item) => {
                item.angle += delta * 0.5;
                const r = 3.5;
                item.sprite.position.x = Math.cos(item.angle) * r;
                item.sprite.position.z = Math.sin(item.angle) * r;
                item.sprite.position.y = 0.5 + Math.sin(elapsedTime * 1.2 + item.offset) * 0.4;
            });

            controls.update();
            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
