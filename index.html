<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Valentine Card for Yusra</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', 'Arial', sans-serif;
        }
        #main-message {
            position: absolute;
            top: 30px;
            left: 0;
            width: 100%;
            text-align: center;
            color: white;
            text-shadow: 0 0 20px #ff4d6d, 0 0 40px #ff4d6d;
            z-index: 10;
            font-size: 2.8rem;
            font-weight: 600;
            letter-spacing: 2px;
            animation: glowPulse 3s infinite alternate;
            pointer-events: none;
        }
        @keyframes glowPulse {
            0% { text-shadow: 0 0 20px #ff4d6d, 0 0 40px #ff4d6d, 0 0 60px #ff4d6d; }
            100% { text-shadow: 0 0 30px #ff8aa1, 0 0 60px #ff4d6d, 0 0 90px #ff1e4d; }
        }
        #letter {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 85%;
            max-width: 650px;
            background: rgba(20, 10, 20, 0.7);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-left: 5px solid #ff99aa;
            border-radius: 24px;
            padding: 25px 30px;
            color: #fff0f5;
            font-size: 1.15rem;
            line-height: 1.7;
            box-shadow: 0 20px 40px rgba(0,0,0,0.5), 0 0 0 1px rgba(255,255,255,0.05) inset;
            z-index: 20;
            font-family: 'Georgia', 'Times New Roman', serif;
            max-height: 50vh;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #ff99aa rgba(0,0,0,0.3);
            pointer-events: none; /* keeps canvas interactive, but text is readable */
        }
        #letter::-webkit-scrollbar {
            width: 6px;
        }
        #letter::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }
        #letter::-webkit-scrollbar-thumb {
            background: #ff99aa;
            border-radius: 10px;
        }
        #letter p {
            margin: 0 0 18px 0;
            text-shadow: 0 2px 5px rgba(0,0,0,0.3);
        }
        #letter .signature {
            font-style: italic;
            text-align: right;
            font-size: 1.4rem;
            color: #ffc0cb;
            margin-top: 20px;
            border-top: 1px dashed rgba(255,255,255,0.2);
            padding-top: 15px;
        }
        .instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255,255,255,0.5);
            font-size: 0.9rem;
            z-index: 15;
            pointer-events: none;
            background: rgba(0,0,0,0.3);
            padding: 6px 12px;
            border-radius: 30px;
            backdrop-filter: blur(4px);
        }
        @media (max-width: 700px) {
            #main-message { font-size: 2rem; top: 15px; }
            #letter { font-size: 1rem; padding: 20px; width: 90%; bottom: 20px; }
        }
    </style>
</head>
<body>
    <div id="main-message">ðŸ’— Happy Valentine's Day, Yusra ðŸ’—</div>
    
    <div id="letter">
        <p>On this special day, I want to take a moment to express just how much you mean to me. Every day with you feels like a beautiful adventure, and I cherish every moment we share.</p>
        <p>Your smile lights up my world, and your laughter is music to my ears. I love the way you make even the simplest moments feel extraordinary. You inspire me to be a better person, and I am so grateful for your love and support.</p>
        <p>As we celebrate this day of love, I want you to know that my heart is yours, now and always. Thank you for being my partner, my confidant, and my greatest joy. I look forward to creating many more beautiful memories together.</p>
        <div class="signature">With all my love,<br>Your sweetheart Abhinav ðŸ’—ðŸŽ€</div>
    </div>

    <div class="instructions">âœ¨ Drag to rotate â€¢ Scroll to zoom â€¢ Autoâ€‘rotate enabled âœ¨</div>

    <!-- Three.js imports -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // --- Scene setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0718); // deep purple-black

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(5, 2.5, 8);
        camera.lookAt(0, 0.5, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        // CSS2 renderer for floating hearts (optional but we'll keep)
        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        labelRenderer.domElement.style.left = '0px';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(labelRenderer.domElement);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 1.8;
        controls.enableZoom = true;
        controls.maxPolarAngle = Math.PI / 2;
        controls.target.set(0, 0.8, 0);

        // --- Lighting ---
        // Ambient
        const ambient = new THREE.AmbientLight(0x40406b);
        scene.add(ambient);

        // Key light (warm)
        const keyLight = new THREE.DirectionalLight(0xffccaa, 1.2);
        keyLight.position.set(3, 5, 4);
        keyLight.castShadow = true;
        keyLight.receiveShadow = true;
        keyLight.shadow.mapSize.width = 1024;
        keyLight.shadow.mapSize.height = 1024;
        const d = 8;
        keyLight.shadow.camera.left = -d;
        keyLight.shadow.camera.right = d;
        keyLight.shadow.camera.top = d;
        keyLight.shadow.camera.bottom = -d;
        keyLight.shadow.camera.near = 2;
        keyLight.shadow.camera.far = 20;
        scene.add(keyLight);

        // Fill light (cool)
        const fillLight = new THREE.PointLight(0x88aaff, 0.6);
        fillLight.position.set(-3, 1, 3);
        scene.add(fillLight);

        // Back rim light
        const rimLight = new THREE.PointLight(0xff99aa, 0.8);
        rimLight.position.set(0, 2, -5);
        scene.add(rimLight);

        // Heart glow point light
        const heartGlow = new THREE.PointLight(0xff3366, 1.5, 10);
        heartGlow.position.set(0, 0.8, 1.5);
        scene.add(heartGlow);

        // --- Create a parametric heart mesh (more realistic) ---
        // Using a parametric function to generate a heart-shaped mesh
        // We'll create a custom geometry by sampling points
        const heartGeo = new THREE.BufferGeometry();
        const vertices = [];
        const indices = [];
        const normals = [];
        const uvs = [];

        // Parameters
        const segments = 64;
        const rings = 32;

        for (let j = 0; j <= rings; j++) {
            const phi = (j / rings) * Math.PI * 2; // 0 to 2PI
            for (let i = 0; i <= segments; i++) {
                const theta = (i / segments) * Math.PI * 2;
                
                // Heart parametric equations
                // x = 16 sin^3 t
                // y = 13cos t - 5 cos 2t - 2cos 3t - cos 4t  (scaled down)
                // But we need 3D: use spherical coordinates with heart shape
                // Simpler: use a standard parametric heart and extrude?
                // Instead, let's generate a heart shape by scaling a sphere based on angle
                
                // More reliable: use the "Taubin" formula
                // We'll create a parametric surface with radius varying by theta and phi
                const t = theta; // longitude
                const p = phi;   // latitude
                
                // Heart shape function in 2D (x,z) scaled, with y as height
                // We'll map phi to height and theta to angle around
                // Actually better: start with a sphere and deform
                // Let's do a simple heart: two spheres and a cone is fine, but for a pro look, we want smooth.
                // I'll use a combined approach: generate points using a parametric heart equation in 2D, then rotate around Y? That gives a torus-like shape, not a heart.
                // To save time and ensure visual appeal, I'll keep the previous heart group but enhance it with better materials and a subtle glow.
                // However, the user wants "prophesnal and good and add some annimated images". So the current heart is acceptable if we add sparkles and animated hearts.
                // I'll stick with the group heart but improve it: add a glass-likeæè´¨ with env map.
            }
        }

        // Instead of complex parametric, we'll enhance the existing heart group with better materials and a shiny env map.
        // Create a canvas environment map for reflections
        const envMapCanvas = document.createElement('canvas');
        envMapCanvas.width = 64;
        envMapCanvas.height = 64;
        const ctx = envMapCanvas.getContext('2d');
        const gradient = ctx.createLinearGradient(0, 0, 64, 64);
        gradient.addColorStop(0, '#ff99aa');
        gradient.addColorStop(0.5, '#ffffff');
        gradient.addColorStop(1, '#ff3366');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);
        const envMapTexture = new THREE.CanvasTexture(envMapCanvas);
        
        // Main heart group (refined)
        const heartGroup = new THREE.Group();

        const material = new THREE.MeshStandardMaterial({
            color: 0xff3366,
            emissive: 0x440000,
            roughness: 0.2,
            metalness: 0.3,
            emissiveIntensity: 0.8,
            envMap: envMapTexture,
            envMapIntensity: 0.5
        });

        // Left lobe (slightly larger and smoother)
        const sphere1 = new THREE.Mesh(new THREE.SphereGeometry(1.05, 48, 48), material);
        sphere1.position.set(-1.15, 0.6, 0);
        sphere1.scale.set(1, 0.9, 0.8);
        sphere1.castShadow = true;
        sphere1.receiveShadow = true;
        heartGroup.add(sphere1);

        // Right lobe
        const sphere2 = new THREE.Mesh(new THREE.SphereGeometry(1.05, 48, 48), material);
        sphere2.position.set(1.15, 0.6, 0);
        sphere2.scale.set(1, 0.9, 0.8);
        sphere2.castShadow = true;
        sphere2.receiveShadow = true;
        heartGroup.add(sphere2);

        // Bottom tip (using a cone with smoother transitions)
        const tipGeo = new THREE.ConeGeometry(0.95, 1.7, 64);
        const tipMat = new THREE.MeshStandardMaterial({ color: 0xff3366, emissive: 0x330000, roughness: 0.25, metalness: 0.2, envMap: envMapTexture });
        const tip = new THREE.Mesh(tipGeo, tipMat);
        tip.position.set(0, -0.7, 0);
        tip.scale.set(0.9, 0.8, 0.7);
        tip.castShadow = true;
        tip.receiveShadow = true;
        heartGroup.add(tip);

        // Add a small sphere at bottom to smooth
        const bottomSphere = new THREE.Mesh(new THREE.SphereGeometry(0.6, 24), material);
        bottomSphere.position.set(0, -1.3, 0.1);
        bottomSphere.scale.set(0.7, 0.4, 0.5);
        bottomSphere.castShadow = true;
        bottomSphere.receiveShadow = true;
        heartGroup.add(bottomSphere);

        // Add a glowing inner heart (smaller, brighter)
        const innerMat = new THREE.MeshStandardMaterial({
            color: 0xff88aa,
            emissive: 0xff3366,
            emissiveIntensity: 0.8,
            transparent: true,
            opacity: 0.7
        });
        const innerSphere1 = new THREE.Mesh(new THREE.SphereGeometry(0.7, 32), innerMat);
        innerSphere1.position.set(-0.8, 0.5, 0.3);
        innerSphere1.scale.set(0.8, 0.7, 0.6);
        heartGroup.add(innerSphere1);
        
        const innerSphere2 = new THREE.Mesh(new THREE.SphereGeometry(0.7, 32), innerMat);
        innerSphere2.position.set(0.8, 0.5, 0.3);
        innerSphere2.scale.set(0.8, 0.7, 0.6);
        heartGroup.add(innerSphere2);

        scene.add(heartGroup);

        // --- Animated ring of heart sprites ---
        // Create heart texture via canvas
        function createHeartTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 64, 64);
            
            // Draw a heart
            ctx.fillStyle = '#ff3366';
            ctx.shadowColor = '#ff99aa';
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.moveTo(32, 52);
            ctx.bezierCurveTo(12, 36, 0, 24, 16, 8);
            ctx.bezierCurveTo(24, 0, 32, 4, 32, 12);
            ctx.bezierCurveTo(32, 4, 40, 0, 48, 8);
            ctx.bezierCurveTo(64, 24, 52, 36, 32, 52);
            ctx.fill();
            return new THREE.CanvasTexture(canvas);
        }

        const heartTexture = createHeartTexture();
        const spriteMaterial = new THREE.SpriteMaterial({ 
            map: heartTexture,
            blending: THREE.AdditiveBlending,
            depthTest: true,
            depthWrite: false
        });

        const ringCount = 12;
        const ringSprites = [];
        for (let i = 0; i < ringCount; i++) {
            const sprite = new THREE.Sprite(spriteMaterial);
            const angle = (i / ringCount) * Math.PI * 2;
            const radius = 3.2;
            sprite.position.set(
                Math.cos(angle) * radius,
                0.8 + Math.sin(angle * 3) * 0.5,
                Math.sin(angle) * radius
            );
            sprite.scale.set(0.8, 0.8, 1);
            scene.add(sprite);
            ringSprites.push({ sprite, angle, speed: 0.5 + Math.random() * 0.5, offset: Math.random() * 10 });
        }

        // --- Floating particles (sparkles) ---
        const particleCount = 600;
        const particlesGeo = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);
        const color = new THREE.Color();

        for (let i = 0; i < particleCount; i++) {
            // Spherical distribution
            const r = 3 + Math.random() * 5;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            positions[i*3] = r * Math.sin(phi) * Math.cos(theta);
            positions[i*3+1] = r * Math.sin(phi) * Math.sin(theta);
            positions[i*3+2] = r * Math.cos(phi);

            const hue = 0.95 + Math.random() * 0.15;
            color.setHSL(hue, 0.9, 0.6 + Math.random() * 0.4);
            colors[i*3] = color.r;
            colors[i*3+1] = color.g;
            colors[i*3+2] = color.b;
            
            sizes[i] = Math.random() * 0.3 + 0.1;
        }
        particlesGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particlesGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        particlesGeo.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

        const particleMat = new THREE.PointsMaterial({
            size: 0.15,
            vertexColors: true,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            sizeAttenuation: true
        });
        const particles = new THREE.Points(particlesGeo, particleMat);
        scene.add(particles);

        // --- Star background (moving) ---
        const starsGeo = new THREE.BufferGeometry();
        const starsPos = new Float32Array(800 * 3);
        for (let i = 0; i < 800; i++) {
            starsPos[i*3] = (Math.random() - 0.5) * 80;
            starsPos[i*3+1] = (Math.random() - 0.5) * 50;
            starsPos[i*3+2] = (Math.random() - 0.5) * 80 - 30;
        }
        starsGeo.setAttribute('position', new THREE.BufferAttribute(starsPos, 3));
        const starsMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.15, transparent: true, opacity: 0.7, blending: THREE.AdditiveBlending });
        const stars = new THREE.Points(starsGeo, starsMat);
        scene.add(stars);

        // --- Reflective ground plane (invisible but catches shadows) ---
        const groundGeo = new THREE.CircleGeometry(12, 32);
        const groundMat = new THREE.MeshStandardMaterial({ color: 0x1a0f1a, emissive: 0x110011, transparent: true, opacity: 0.2, side: THREE.DoubleSide });
        const ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -1.8;
        ground.receiveShadow = true;
        scene.add(ground);

        // --- Animation loop ---
        let clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const elapsedTime = performance.now() / 1000;

            // Heartbeat scale
            const beat = Math.sin(elapsedTime * 8) * 0.02;
            heartGroup.scale.setScalar(1 + beat);

            // Rotate particles
            particles.rotation.y += 0.0003;
            particles.rotation.x += 0.0001;
            
            // Rotate stars slowly
            stars.rotation.y += 0.0001;

            // Animate ring sprites: rotate around heart and bob up/down
            ringSprites.forEach((item, index) => {
                const newAngle = item.angle + delta * 0.8;
                item.angle = newAngle;
                const radius = 3.2;
                const yOffset = Math.sin(elapsedTime * 2 + index) * 0.4;
                item.sprite.position.x = Math.cos(newAngle) * radius;
                item.sprite.position.z = Math.sin(newAngle) * radius;
                item.sprite.position.y = 0.8 + yOffset;
            });

            controls.update();

            renderer.render(scene, camera);
            labelRenderer.render(scene, camera);
        }

        animate();

        // --- Resize handler ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
